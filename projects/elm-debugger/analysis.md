---
title: Elm Debugger
author: Jonas Chromik
bibliography: references.bib
---

# Live Programming Seminar
- Your Name: Jonas Chromik
- Your Topic: Elm Debugger

>Generally try to drill down on reasons behind properties of the system. Make use of the general observations about the system in arguing about specific properties or mechanisms.

## About the System itself
>Summary of system properties

The system studied is the time-traveling Elm Debugger.
Actually there are at least three different time-traveling debuggers for Elm. In chronological order according to the time of development:
 1. The native Elm package `core/Debug`.
 2. The third-party package `jinjor/elm-time-travel`.
 3. The runtime debugger.

In the following we shortly describe the properties of the three debuggers.

#### core/Debug
This is the first time-traveling Elm debugger which was published first with Elm 0.12 and the Elm `core` package in version 1.0.0. Later, the time-traveling features were removed from the `core/Debug` package in version 4.0.0.
<<< TODO: WHY? >>>
Due to dependency issues and fast changes in the Elm language itself as well as in its packages, it is now hard to create an Elm setup that is capable of running this time-traveling Debugger.
<<< TODO: MORE ABOUT THE ISSUES? >>>
Nevertheless, this Debugger is deployed at [http://debug.elm-lang.org/](http://debug.elm-lang.org/) and can be tried out there. The site provides three examples that make use of the `core/Debug` package.
The tool is structured as follows:
 - Leftmost there is an editor that shows Elm source code. The source code can be changed. Adaption takes place automatically as the user types.
 - In the middle there is an area that show the web page generated by the source code.
 - Rightmost there is an area that shows two buttons, a slider and a pane for observed variables.
   - The sliders purpose is scrolling through the input history. Input can be time events, mouse movements, clicks, as well as keyboard input. The examples source code decides which input is relevant. If the Elm application under observation only listens on mouse input, everything but mouse input is ignored. The slider can be used to revert and replay input.
  - Of the two buttons one is for pausing the execution in terms of not accepting input anymore. By clicking the button again, the execution is resumed.
  - The other button is for clearing the input history.
  - The pane for observed variables shows the content of these variables at the current point in input history. The pane does not show the whole state of the application. Only variables that are selected using the `Debug.watch` statement in the source code.


#### jinjor/elm-time-travel
After the time-traveling features were removed from `core/Debug`, there was no time-traveling Debugger in Elm anymore. Therefore Yosuke Torii (jinjor) created the package `jinjor/elm-time-travel` which is based on Elm 0.17 and aims for being a replacement for `core/Debug`. Examples using this package are deployed at [http://jinjor.github.io/elm-time-travel/](http://jinjor.github.io/elm-time-travel/). Comparing this site with [http://debug.elm-lang.org/](http://debug.elm-lang.org/) shows, that both have a similar structure despite there are differences.
In contrast to `core/Debug`, this package does not show source code. There is only a two-part view which shows the generated web page on the left and a tool bar on the right. The tool bar does, other than `core/Debug`, not show variables or its content but message send (which are corresponding to input). By selecting a very message send, the user can jump to the point in execution where the message send happened. The debugger than pauses the execution and shows the Elm applications model before and after the message send happened. Like in `core/Debug`, the message/input history is immutable. Generating more input does not change the history at the point currently inspected but rather appends another message to the history.

#### Runtime Debugger
The Elm version 0.18 introduced a debugger that is not a package that can be invoked in the source code but rather part of the runtime environment. The debugger is invoked when the Elm application is built using the Elm Reactor (`elm-reactor`) or Elm Make with debug flag set (`elm-make Application.elm --debug`). The debugger than appears as a box in the bottom right corner of the application under observation. This box has three parts:
 1. The top part is captioned "Explore History" and shows the number of message sends in brackets behind the caption. Clicking on it opens the window described below.
 2. An "Import" button that opens a file dialog where the user can select a history file which is then replayed.
 3. An "Export" button that opens a file dialog where the user can save the current history.

The window that opens when clicking "Explore History" shows the message history on the left. On the right there is an area that displays the model an the time the selected message was send. Also, when selecting a certain message send, the application is brought back to the point when the message send took place.

The idea behind the import/export concept is to create more meaningful and reproducible bug reports. Unfortunately this deprives the debugger of live development features.

#### Analyzed System
Initially the `core/Debug` package was the system to be analyzed. After finding out about the difficulties of setting up an Elm environment that is capable of running the debugger, we decided to rather analyze the newer Elm runtime debugger. Considerations that led us to that decision were:
 - The time-traveling `core/Debug` package is hard to set up due to the fact that it was built on a much older Elm version which is highly different from the current Elm implementation. We had to use an old Elm version (0.12) which was, other than newer versions, not available via the Node package manager but only via Haskell and Cabal. Since we do not have much knowledge about Haskell and Cabal and moreover ran into dependency conflicts, we assumed it would be easier to make use of another debugger.
 - Even if we were able to set up an old Elm version capable of running the `core/Debug` debugger, the results of our analysis would not be easily reproducible since everyone else would also have to got through the complicated set-up process. Newer version of Elm are easier to set up (using NPM).
 - The development of Elm is really fast-paced. Therefore we argue that using the newest possible version is crucial to make sure the results of our analysis are easily reproducible as long as possible. Using `core/Debug` which is the oldest of the three considered debuggers would contradict this argument.
 - Over time, Elm moved from a Haskell based implementation more and more to JavaScript. With the two newer debuggers (`jinjor/elm-time-travel` and the runtime debugger) there was no need to deal with Haskell or Cabal. We only had to cope with JavaScript and NPM which we considered to be easy since we already had experience with that.

For our analysis we decided use a modified version of the runtime debugger. We could not use the original version because the live programming features (i.e. live reloading and live replaying of history) were removed in favor of saving/loading the history to/from a file.

The following section describes how we changed the runtime debugger to satisfy our needs.

#### Runtime Debugger Modifications
The package that creates the debugger interface is the `elm-lang/virtual-dom` package. Among others, it is responsible for the debugger box in the bottom right corner, the debugger window showing message sends and state of the application, as well as functionality for importing and exporting history including history replay after a history file is loaded.
For enabling live history replay, did the following:
 1. Add a button "Store" that works like the "Export" button but stores the history in the session storage rather than in a user selected file. Therefore this button provides a one-click functionality.
 2. Add a button "Load" that works like the "Import" button but loads the history from the session storage rather than from a user selected file. Like "Store", this button is also a one-click feature.
 3. Add a window `load` listener that triggers a `click` event on the "Load" button when the page is loaded.
 4. Add a window `beforeunload` listener that triggers a `click` event on the "Store" button when the page about to be left.
 5. Add a "Clear" button that clears the session storage and than reloads the page preventing the `beforeunload` listener to store the history.

The indirection of triggering click events on the "Load" and "Store" buttons is necessary, because calling the functions for loading and storing right away would require creating `load` and `beforeunload` listeners in the Elm source code. Unfortunately we were not able to find a good way of doing this.
All changes took place in `elm-lang/virtual-dom` in version 2.0.2, the most recent version at the time of writing this (2016-12-04). The modified version of the package can be found at [https://github.com/jchromik/virtual-dom](https://github.com/jchromik/virtual-dom) which is a fork of [https://github.com/elm-lang/virtual-dom](https://github.com/elm-lang/virtual-dom).

The following sections describes how the modified debugger can be used.

#### Runtime Debugger Setup
To achieve an impression of liveness inside the Elm runtime debugger, two steps need to be performed:
 1. Exchange the original `elm-lang/virtual-dom` package with the modified one described above.
 2. Apply live reloading on the Elm application.

Exchanging the `elm-lang/virtual-dom` is done as follows: After installing the Elm packages required for your projects (this are at least `elm-lang/core`, `elm-lang/html`, and `elm-lang/virtual-dom`) replace the contents of the folder where your copy of `elm-lang/virtual-dom` lies in with the contents of [https://github.com/jchromik/virtual-dom](https://github.com/jchromik/virtual-dom). An `elm-lang/virtual-dom` package in version 2.0.2 should be located in  `elm-stuff/packages/elm-lang/virtual-dom/2.0.2`. The modifications made are based on 2.0.2. Other versions starting with 2 may work as well since there are only minor changes between the versions.
Now live replaying history when refreshing the page should work when using the Elm Reactor. Also, the buttons "Load", "Store", and "Clear" should be visible below the "Import" and "Export" buttons.
The next step describes how to automatically reload the page when a change has happened.

We need to setup a live reload server that watches the files under development and issues a page reload if any file was changed. Also, we need either a script or a browser plug-in, that reloads the page, whenever the live reload server fires.
There are many ways to achieve such a setup. We only describe one possible way.
 1. Install a Node.js based live reload server with `npm install -g livereload` (for more informations see [https://github.com/napcs/node-livereload](https://github.com/napcs/node-livereload))
 2. Install a browser plug-in that listens on the live reload server. We used [http://livereload.com/extensions/](http://livereload.com/extensions/) and installed it on a Chromium Browser from the Google Web Store.
 3. Start the Elm Reactor in your project directory with `elm-reactor`.
 4. Start the live reload server and tell to watch your project directory including Elm files with `livereload /path/to/project -e 'elm'`.
 5. Open a browser, enable the live reload plug-in and visit your project. This is usually on `http://localhost:8000`.
 6. Start developing.

There is an example project at [https://github.com/jchromik/lps16-elm-examples](https://github.com/jchromik/lps16-elm-examples) that shows prerequisites, setup and start-up process.

### System boundaries
>What have you looked at exactly? Mention the boundaries of the system and state what is included and excluded. For example, in Chrome the system might be the developer tools. This ignores any JavaScript libraries which might add additional live capabilities to the tools or to the page currently developed. Another example are auto-testing setups which span a particular editor, testing framework, and auto-testing tool.

This work studies a modified version of the debugging features introduced in Elm 0.18. The modifications were necessary to enable live programming related features that were not present before. Initially the `core/Debug` debugger which included the aforementioned live programming features was subject to this work. We changed the subject to the runtime debugger. The reasons are listed in the previous section.
The debugging features studied include means of
 - viewing the message history,
 - inspecting the state of the application,
 - going back in time by partially replaying the message history, as well as
 - importing and exporting the message history.

Furthermore we study the features we added, namely:
 - storing history to the session storage
 - loading history from the session storage
 - clearing the history from the session storage
 - live (in terms of automatically) replaying the existing history on page reload
 - live (in terms of automatically) reloading the page if a file has been changed

We do not cover the Elm language itself or any parts related to the execution environment. Operating systems, browsers, and all parts of the Elm execution environment not related to the stated debugging features are not covered.
The focus lies on how the user interacts with the debugger.

### Context
>  - In which context is the system used?
    For example: Application development (coding, debugging, exploration), education, art, science (data exploration), simulation, exploration of ideas or data.
>  - Description of user context
    (professional, amateur, public presentation in front of audience, (un)known requirements, children, ...)

 - The context of the system is Application development in general and debugging of Elm applications in special.
 Furthermore the Elm debugger can also be used for understanding the behavior of an application without any bug involved. Therefore code exploration is also considerable use case.
 - The Elm programming language is relatively new and therefore it does not have a large user base. Hence it is not clear how the debugger will be used. Concluding from other programming language and debuggers, the Elm debugger will probably be used for professional and/or amateur software development. We assume an amateur user context is more likely because the user interface is simple and the setup overhead is small.

### General Application Domain
>  - What is typically created in or through this system?
>  - What are users trying to accomplish with it?
>  - What kind of systems are modified or developed with it (graphical application, client-server architecture, big data, streaming)?
>  - ...

- Typical output of the system is a bug-free Elm source code file. The features for exporting and importing message history are used for creating meaningful bug reports. With an explicit message history, bugs are easily reproducible which helps finding a bug.  
- The user either tries to find a bug in a piece of Elm source code or tries to understand how the source code works. Like in other debuggers too, the goal is understanding why and how an application works.
- Subject to the Elm debugger are websites built with Elm. Elm is a functional programming language on top of Node.js. Main use case of Elm is the construction of web user interfaces using a model-view-update (<?>) pattern.

### Design Goals of the System
>What is the design rational behind the system? Which values are supported by the system? Which parts of the system reflect this rational? For example, auto-testing setups are designed to improve productivity by improving the workflow for TDD through providing feedback on the overall system behavior during programming. Smalltalk systems are designed for expressiveness and enabling understanding through allowing users to directly access and manipulate all runtime objects in the system.

The time-traveling Elm debugger helps understanding, how a specific change in the applications source code affects the applications output in context of the input given by the user.
Although the tool is called a debugger, its main purpose is improving the developers understanding of an application rather than finding bugs.
The time-traveling features help getting a meaningful impression of the connection between change in source code and its effect by providing access to all input that already happened rather than only the current input. Replaying the input helps finding out not only what the change in source code does to the current state but also what it would have done to every state before.

### Type of System
>What is the general nature of the system? For example: interactive tool, system, library, language, execution environment, application. What makes the system part of that category?

The system is an interactive tool because it is interactive and it is a tool.  
The system is interactive since the user can interact with it. The content shown is not static but changes when the user for example goes back in time by selecting different points in the message history.
The system is a tool because it helps developing Elm applications but is not necessarily required.
Please note, the system under analysis is not the Elm runtime environment. We only analyze the debugging features.

---

## Workflows
>Summary of workflow observations

### Example Workflow
>Description of the major workflow which illustrates all relevant "live programming" features. The workflow description should cover all major elements and interactions available. Augmented by annotated pictures and screencast.

The setup for using the Elm debugger consists of three components.
 1. A text editor for changing the source code of the observed Elm application.
 2. A live reload server for automatically adapting changes in source code.
 3. An Elm setup with modified debugging features.
 4. A browser satisfying the following conditions:
   1. The browser provides a live reload plug-in that listens to the live reload server and reloads the page if the live reload server notices a change in the observed files.
   2. The browser shows the output of the Elm Reactor running the observed Elm application. This is usually served on `http://localhost:8000`.

The browser than shows the Elm application with some additional UI elements for interacting with the debugger. This was already described in the section "About the System itself / Runtime Debugger".

A usual interaction with the system is as follows:
 1. Edit source code using the text editor.
 2. Save the file.
 3. The live reload server notices the files changed and send an event to the browser plug-in.
 4. The browser plug-in reloads the page.
 5. Before unloading the page for reload, the modified debugger saves the message history to the session storage.
 6. After (re)loading the page, the modified debugger replays the message history from the session storage.

After this cycle the Elm application is in the same situation as before (in terms of input) but with changed source code and therefore potentially changed behavior. Therefore also the state of the application may be different.
Although a change in source code is immediately adapted, it may take some time until changed behavior emerges (see @Rein2016HLL on Adaption and Emergence). Replaying in connection with the users ability to roll back parts of the input helps finding a sequence of user interaction that makes the change emerge. The area showing watched values helps understanding why a certain behavior occurs.

### Which activities are made live by which mechanisms?
>Description of each concrete activity in the workflow and the underlying liveness mechanism (which is described on a conceptual level and thus could be mapped to other systems)
- Actual interactions
- Feedback mechanism
- If applicable: How is the emergence phase shortened?
- Granularity: For example: Elm can only rerun the complete application

In the cycle of changing code and observing changes behavior can be split in three phases:

#### Editing, recompiling and reloading code
When code is changed, the Elm debugger automatically recompiles the code and reloads the application. This happens immediately without the user triggering these actions explicitly. This corresponds to liveness level 4 (see @Tanimoto2013PEL). The adaption time is usually fast (less than 1 second) and may only slow down due to the next phase (replaying input).

#### Replaying input
After recompiling and reloading, the Elm debugger tries to bring the application back to the state it had before. This is tried to achieve by replaying all relevant input. By doing this, the user has the experience as if the change made was always there (past input is processed again by the changed algorithm).
The advantage of replaying input rather than restoring the applications state in terms of values bound to variables is avoidance of inconsistencies. We can not assume that the changes application can deal with the same state the application before did. Therefore that application has to start off with a blank state and process input made in order to achieve the state present before the change.
The principle behind this step is "continuous feedback". The user does not have to restore the state themself since the debugger does it for him. This makes programming a continuous process with permanent feedback and permanent correction (cf. @Hancock2003RTP).

#### Observing Emergence
Observing emergence is hard because the time a change needs to emerge depends on the change itself. Although adaption is done quickly, it can take a long time until the application reaches a state where the change emerges. It is also possible that a change does not emerge at all. This happens, when the piece of source code where the change was done is unreachable.
However, the time-traveling features of the Elm debugger make it easier to observe emergence of a change by not only showing the current state but also making all previous states of the application easily accessible. This implies that a change is observable as soon as it effect the application in any state the application was already in. Therefore the programmer can easily find out, if a change made is meaningful for the input that already happened. If there is no evidence for the emergence of the change in context of the previous input, the programmer has to generate further input to provoke emergence.

There may be changes that do not affect the user interface of an application but only change internal, not so easily observable, behavior. The debuggers ability to show watched values separately helps finding these cases of emergence.

#### Granularity
The smallest granularity of change is the whole application together with all previous input. Whenever the source code of the application is changed, the debugger has to recompile and restart that application together with replaying all input. This may take a long time if the granularity of input is small (e.g. millisecond-wise timer events) and therefore much input happened. This leads to low performance for some kinds of applications.

### Integration of live activities into overall system
>Which activities in the system are not interactive anymore? Which elements can be manipulated in a live fashion and which can not?

- No interactive changes of values in running application
- But: sliders in source code with live-reload
- Immutable past. Input that already happened can not be changed
- Liveness breaks apart for large amounts of input
- Liveness interrupts when code is syntactically (?) incorrect (e.g. in terms of types)
- Application itself is not live.
- Browser is (usually) live.

>How does this workflow integrate with other parts of the system (potentially not live)? What happens at the boundaries between live parts and non-live parts? For example, the interactively assembled GUI is later passed to a compiler which creates an executable form of the GUI.

 - no idea up to now, maybe a short list due to strong liveness (?)

### Limitations
>To which extend can the liveness of one activity be kept up? For example, at which magnitude of data flow nodes does the propagation of values become non-immediate? At which magnitude of elapsed time can the Elm debugger not replay the application immediately anymore or when does it break down? Does an exception break the liveness?

 - Slowdown is continuous and system dependent. Can not give a concrete number. But: there is is slowdown for much input. Have to find out when it goes about the 100ms / 1s threshold.
 - Yes, exception cause the liveness to interrupt, but not break down since it resumes when the exception is removed.

>Further, what are conceptual limitations. For example, in a bi-directional mapping system properties of single elements might be modified and reflected in the code. This might not be possible for properties of elements created in loops.

### What happens when the live parts of the system fail/break?
>1. What happens when the application under development causes an exception? How does the system handle these exceptions (provide debugger, stop execution, stop rendering, ...)? Does the liveness extend to these exceptions?
>2. How can the system itself break? What happens when there is a failure in the system/tool itself?

### Left out features
>Which features of the system were not described and why were they left out?

 - debugger features that are not live (i.e. the console debugging functions 'log' and 'crash')
 - multi-file / multi-page applications

---

## Models

### Mutable or immutable past
>To which category does the system or parts of it belong and why?

*P. Rein and S. Lehmann and Toni & R. Hirschfeld How Live Are Live Programming Systems?: Benchmarking the Response Times of Live Programming Environments Proceedings of the Programming Experience Workshop (PX/16) 2016, ACM, 2016, 1-8*

### Tanimoto's Level of Live Programming
To which level of liveness do single activities belong, based on the definitions of the 2013 paper and why?
>
*S. L. Tanimoto A perspective on the evolution of live programming Proceedings of the 1st International Workshop on Live Programming, LIVE 2013, 2013, 31-34*

### Steady Frame
>Which activities are designed as steady frames based on the formal definition and how?

*C. M. Hancock Real-Time Programming and the Big Ideas of Computational Literacy Massachusetts Institute of Technology, Massachusetts Institute of Technology, 2003*

### Impact on distances
>How do the activities affect the different distances: temporal, spatial, semantic?

*D. Ungar and H. Lieberman & C. Fry Debugging and the Experience of Immediacy Communications of the ACM, ACM, 1997, 40, 38-43*

---

## Implementing Liveness

### Extend of liveness in technical artifacts
>What parts of the system implements the liveness? (Execution environment, library, tool...)

### Implementations of single activities
>Description of the implementation of live activities. Each implementation pattern should be described through its concrete incarnation in the system (including detailed and specific code or code references) and as an abstract concept.

#### Example: Scrubbing
>The mouse event in the editor is captured and if the underlying AST element allows for scrubbing a slider is rendered. On changing the slider the value in the source code is adjusted, the method including the value is recompiled. After the method was compiled and installed in the class, the execution continues. When the method is executed during stepping the effects of the modified value become apparent.

>Abstract form: Scrubbing is enabled through incremental compilation which enables quick recompilation of parts of an application...

### Within or outside of the application
>For each activity: Does the activity happen from within the running application or is it made possible from something outside of the application? For example, a REPL works within a running process while the interactions with an auto test runner are based on re-running the application from the outside without any interactive access to process internal data.

---

## Benchmark
>1. **Unit of change:** Determine relevant units of change from the user perspective. Use the most common ones.
>2. **Relevant operations:** Determine relevant operations on these units of change (add, modify, delete, compound operations (for example refactorings)).
>3. **Example data:** Select, describe, and provide representative code samples which reflect the complexity or length of a common unit of change of the environment. The sample should also work in combination with any emergence mechanisms of the environment, for example a replay system works well for a system with user inputs and does not match a long-running computation.
>4. **Reproducible setup of system and benchmark**
  1. Description of installation on Ubuntu 16.04.1 LTS
  2. Description of instrumentation of system for measurements: The measurements should be taken as if a user was actually using a system. So the starting point of a measurement might be the keyboard event of the save keyboard shortcut or the event handler of a save button. At the same time the emergence phase ends when the rendering has finished and the result is perceivable. The run should include all activities which would be triggered when a developer saves a unit of change (for example regarding logging or persisting changes).
>5. **Results for adaptation and emergence phase**

*P. Rein and S. Lehmann and Toni & R. Hirschfeld How Live Are Live Programming Systems?: Benchmarking the Response Times of Live Programming Environments Proceedings of the Programming Experience Workshop (PX/16) 2016, ACM, 2016, 1-8*

---

## Personal observations
>Everything that is particular about the environment and does not fit into the pre-defined categories mentioned so far.

## Style Template
>- Denote headings with #
>- You can use any text highlighting, list types, and tables
>- Insert images in the following way:
>  `![This is the caption](/url/of/image.png)`
>- Insert videos or web resources as markdown links
>- Insert references as: `@RefKey` and supply a bib file
>- No HTML tags please
