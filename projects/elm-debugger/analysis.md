---
title: Elm Debugger
author: Jonas Chromik
bibliography: references.bib
---

# Live Programming Seminar
- Your Name: Jonas Chromik
- Your Topic: Elm Debugger

>Generally try to drill down on reasons behind properties of the system. Make use of the general observations about the system in arguing about specific properties or mechanisms.

## About the System itself
>Summary of system properties

The system studied is the time-traveling Elm Debugger.
Actually there are at least three different time-traveling debuggers for Elm. In chronological order according to the time of development:
 1. The native Elm package `core/Debug`.
 2. The third-party package `jinjor/elm-time-travel`.
 3. The runtime debugger.

In the following we shortly describe the properties of the three debuggers.

#### core/Debug
This is the first time-traveling Elm debugger which was published first with Elm 0.12 and the Elm `core` package in version 1.0.0. Later, the time-traveling features were removed from the `core/Debug` package in version 4.0.0.
<<< TODO: WHY? >>>
Due to dependency issues and fast changes in the Elm language itself as well as in its packages, it is now hard to create an Elm setup that is capable of running this time-traveling Debugger.
<<< TODO: MORE ABOUT THE ISSUES? >>>
Nevertheless, this Debugger is deployed at [http://debug.elm-lang.org/](http://debug.elm-lang.org/) and can be tried out there. The site provides three examples that make use of the `core/Debug` package.
The tool is structured as follows:
 - Leftmost there is an editor that shows Elm source code. The source code can be changed. Adaption takes place automatically as the user types.
 - In the middle there is an area that show the web page generated by the source code.
 - Rightmost there is an area that shows two buttons, a slider and a pane for observed variables.
   - The sliders purpose is scrolling through the input history. Input can be time events, mouse movements, clicks, as well as keyboard input. The examples source code decides which input is relevant. If the Elm application under observation only listens on mouse input, everything but mouse input is ignored. The slider can be used to revert and replay input.
  - Of the two buttons one is for pausing the execution in terms of not accepting input anymore. By clicking the button again, the execution is resumed.
  - The other button is for clearing the input history.
  - The pane for observed variables shows the content of these variables at the current point in input history. The pane does not show the whole state of the application. Only variables that are selected using the `Debug.watch` statement in the source code.


#### jinjor/elm-time-travel
After the time-traveling features were removed from `core/Debug`, there was no time-traveling Debugger in Elm anymore. Therefore Yosuke Torii (jinjor) created the package `jinjor/elm-time-travel` which is based on Elm 0.17 and aims for being a replacement for `core/Debug`. Examples using this package are deployed at [http://jinjor.github.io/elm-time-travel/](http://jinjor.github.io/elm-time-travel/). Comparing this site with [http://debug.elm-lang.org/](http://debug.elm-lang.org/) shows, that both have a similar structure despite there are differences.
In contrast to `core/Debug`, this package does not show source code. There is only a two-part view which shows the generated web page on the left and a tool bar on the right. The tool bar does, other than `core/Debug`, not show variables or its content but message send (which are corresponding to input). By selecting a very message send, the user can jump to the point in execution where the message send happened. The debugger than pauses the execution and shows the Elm applications model before and after the message send happened. Like in `core/Debug`, the message/input history is immutable. Generating more input does not change the history at the point currently inspected but rather appends another message to the history.

#### Runtime Debugger
The Elm version 0.18 introduced a debugger that is not a package that can be invoked in the source code but rather part of the runtime environment. The debugger is invoked when the Elm application is built using the Elm Reactor (`elm-reactor`) or Elm Make with debug flag set (`elm-make Application.elm --debug`). The debugger than appears as a box in the bottom right corner of the application under observation. This box has three parts:
 1. The top part is captioned "Explore History" and shows the number of message sends in brackets behind the caption. Clicking on it opens the window described below.
 2. An "Import" button that opens a file dialog where the user can select a history file which is then replayed.
 3. An "Export" button that opens a file dialog where the user can save the current history.

The window that opens when clicking "Explore History" shows the message history on the left. On the right there is an area that displays the model an the time the selected message was send. Also, when selecting a certain message send, the application is brought back to the point when the message send took place.

The idea behind the import/export concept is to create more meaningful and reproducible bug reports. Unfortunately this deprives the debugger of live development features.
<<< TODO: DESCRIBE DEBUGGER WINDOW >>>

### System boundaries
>What have you looked at exactly? Mention the boundaries of the system and state what is included and excluded. For example, in Chrome the system might be the developer tools. This ignores any JavaScript libraries which might add additional live capabilities to the tools or to the page currently developed. Another example are auto-testing setups which span a particular editor, testing framework, and auto-testing tool.

This work studies the time-traveling Elm debugger (core/Debug package version 3.0.0 or lower). This includes the debugger framework (tools for replaying input and watching values) together with an observed Elm application. The focus lies on the interaction between user and debugger as well as on the interaction between debugger and application.
<figure>
We do not cover the Elm language itself or packages used with Elm.
The focus is clearly on the liveness of the debugger, not the language itself.

### Context
>  - In which context is the system used?
    For example: Application development (coding, debugging, exploration), education, art, science (data exploration), simulation, exploration of ideas or data.
>  - Description of user context
    (professional, amateur, public presentation in front of audience, (un)known requirements, children, ...)

  - The context of the system is Application development in general and debugging of Elm applications in special.
  Furthermore the Elm debugger can also be used for understanding the behavior of an application without any bug involved. Therefore code exploration is also considerable use case.

  - Since the system under focus is the version of the Elm debugger deployed at `http://debug.elm-lang.org/`, the user context is public presentation of software using a website. Also, the application may be used by amateur Elm developers since the set up effort is low and therefore the system is easily accessible. Professionals will use their own setup of the Elm debugger, though, because the Elm debugger at `http://debug.elm-lang.org/` can only handle one file at a time which is not suitable for larger applications.


### General Application Domain
>  - What is typically created in or through this system?
>  - What are users trying to accomplish with it?
>  - What kind of systems are modified or developed with it (graphical application, client-server architecture, big data, streaming)?
>  - ...

- Typical output of the system is a bug-free Elm source code file. Notice, that the purpose of the system is not only its output but also the user experience while creating the output. The website showing the debugger is for presentational purposes and therefore the users understanding of the concept is important.
- The user either tries to find a bug in a piece of Elm source code or tries to understand how the source code works. Like in other debuggers too, the goal is understanding why and how an application works.
- Subject to the Elm debugger are single-page websites built with Elm. Elm is a functional programming language on top of Node.js. Main use case of Elm is the construction of web user interfaces using a model-view-update (<?>) pattern.

### Design Goals of the System
>What is the design rational behind the system? Which values are supported by the system? Which parts of the system reflect this rational? For example, auto-testing setups are designed to improve productivity by improving the workflow for TDD through providing feedback on the overall system behavior during programming. Smalltalk systems are designed for expressiveness and enabling understanding through allowing users to directly access and manipulate all runtime objects in the system.

The time-traveling Elm debugger helps understanding, how a specific change in the applications source code affects the applications output in context of the input given by the user.
Although the tool is called a debugger, its main purpose is improving the developers understanding of an application rather than finding bugs.
The time-traveling features help getting a meaningful impression of the connection between change in source code and its effect by providing access to all input that already happened rather than only the current input. Replaying the input helps finding out not only what the change in source code does to the current state but also what it would have done to every state before.

### Type of System
>What is the general nature of the system? For example: interactive tool, system, library, language, execution environment, application. What makes the system part of that category?

The system is an interactive tool. It is part of the Elm package system and can be invoked by import and invocation through the source code. It then serves as a debugging framework in which the Elm application is running.

---

## Workflows
>Summary of workflow observations

### Example Workflow
>Description of the major workflow which illustrates all relevant "live programming" features. The workflow description should cover all major elements and interactions available. Augmented by annotated pictures and screencast.

The systems user interface consists of three horizontally aligned parts.
1. Leftmost is an area where the user can view and edit Elm source code. The code is executed and changes are adopted immediately (in less than one second).
2. In the middle there is an area where the running application generated from the code on the left is shown. The user can interact with the application in the same manner as they could without the debugging framework.
3. On the right side there is an area that serves two purposes.
  1. At top is a slider that serves the purpose of going back in time. This is realized by replaying all relevant input. Every input generated either by the user or by clock events counts as a discrete step in time. By dragging the slider input can be rolled back or replayed.
  2. Below the slider there is a pane that shows values the debugger watches. Using the function `Debug.watch` the debugger can be instructed to watch on a given value in source code. The watched value is permanently shown and updated.

A usual interaction with the system is a cycle of editing source code using the editor part on the left side and observing changed behavior in the running application shown in the middle.
Therefore the Elm code is compiled, run and all input that happened prior to the change is replayed. The changed Elm application is then in the same situation (concerning input) as the version before, but with changed behavior due to changes source code. Therefore also the state of the application may be different.
Although a change in source code is immediately adapted, it may take some time until changed behavior emerges (see @Rein2016HLL on Adaption and Emergence). Replaying in connection with the users ability to roll back parts of the input helps finding a sequence of user interaction that makes the change emerge. The area showing watched values helps understanding why a certain behavior occurs.

### Which activities are made live by which mechanisms?
>Description of each concrete activity in the workflow and the underlying liveness mechanism (which is described on a conceptual level and thus could be mapped to other systems)
- Actual interactions
- Feedback mechanism
- If applicable: How is the emergence phase shortened?
- Granularity: For example: Elm can only rerun the complete application

In the cycle of changing code and observing changes behavior can be split in three phases:

#### Editing, recompiling and reloading code
When code is changed, the Elm debugger automatically recompiles the code and reloads the application. This happens immediately without the user triggering these actions explicitly. This corresponds to liveness level 4 (see @Tanimoto2013PEL). The adaption time is usually fast (less than 1 second) and may only slow down due to the next phase (replaying input).

#### Replaying input
After recompiling and reloading, the Elm debugger tries to bring the application back to the state it had before. This is tried to achieve by replaying all relevant input. By doing this, the user has the experience as if the change made was always there (past input is processed again by the changed algorithm).
The advantage of replaying input rather than restoring the applications state in terms of values bound to variables is avoidance of inconsistencies. We can not assume that the changes application can deal with the same state the application before did. Therefore that application has to start off with a blank state and process input made in order to achieve the state present before the change.
The principle behind this step is "continuous feedback". The user does not have to restore the state themself since the debugger does it for him. This makes programming a continuous process with permanent feedback and permanent correction (cf. @Hancock2003RTP).

#### Observing Emergence
Observing emergence is hard because the time a change needs to emerge depends on the change itself. Although adaption is done quickly, it can take a long time until the application reaches a state where the change emerges. It is also possible that a change does not emerge at all. This happens, when the piece of source code where the change was done is unreachable.
However, the time-traveling features of the Elm debugger make it easier to observe emergence of a change by not only showing the current state but also making all previous states of the application easily accessible. This implies that a change is observable as soon as it effect the application in any state the application was already in. Therefore the programmer can easily find out, if a change made is meaningful for the input that already happened. If there is no evidence for the emergence of the change in context of the previous input, the programmer has to generate further input to provoke emergence.

There may be changes that do not affect the user interface of an application but only change internal, not so easily observable, behavior. The debuggers ability to show watched values separately helps finding these cases of emergence.

#### Granularity
The smallest granularity of change is the whole application together with all previous input. Whenever the source code of the application is changed, the debugger has to recompile and restart that application together with replaying all input. This may take a long time if the granularity of input is small (e.g. millisecond-wise timer events) and therefore much input happened. This leads to low performance for some kinds of applications.

### Integration of live activities into overall system
>Which activities in the system are not interactive anymore? Which elements can be manipulated in a live fashion and which can not?

- No interactive changes of values in running application
- But: sliders in source code with live-reload
- Immutable past. Input that already happened can not be changed
- Liveness breaks apart for large amounts of input
- Liveness interrupts when code is syntactically (?) incorrect (e.g. in terms of types)
- Application itself is not live.
- Browser is (usually) live.

>How does this workflow integrate with other parts of the system (potentially not live)? What happens at the boundaries between live parts and non-live parts? For example, the interactively assembled GUI is later passed to a compiler which creates an executable form of the GUI.

 - no idea up to now, maybe a short list due to strong liveness (?)

### Limitations
>To which extend can the liveness of one activity be kept up? For example, at which magnitude of data flow nodes does the propagation of values become non-immediate? At which magnitude of elapsed time can the Elm debugger not replay the application immediately anymore or when does it break down? Does an exception break the liveness?

 - Slowdown is continuous and system dependent. Can not give a concrete number. But: there is is slowdown for much input. Have to find out when it goes about the 100ms / 1s threshold.
 - Yes, exception cause the liveness to interrupt, but not break down since it resumes when the exception is removed.

>Further, what are conceptual limitations. For example, in a bi-directional mapping system properties of single elements might be modified and reflected in the code. This might not be possible for properties of elements created in loops.

### What happens when the live parts of the system fail/break?
>1. What happens when the application under development causes an exception? How does the system handle these exceptions (provide debugger, stop execution, stop rendering, ...)? Does the liveness extend to these exceptions?
>2. How can the system itself break? What happens when there is a failure in the system/tool itself?

### Left out features
>Which features of the system were not described and why were they left out?

 - debugger features that are not live (i.e. the console debugging functions 'log' and 'crash')
 - multi-file / multi-page applications

---

## Models

### Mutable or immutable past
>To which category does the system or parts of it belong and why?

*P. Rein and S. Lehmann and Toni & R. Hirschfeld How Live Are Live Programming Systems?: Benchmarking the Response Times of Live Programming Environments Proceedings of the Programming Experience Workshop (PX/16) 2016, ACM, 2016, 1-8*

### Tanimoto's Level of Live Programming
To which level of liveness do single activities belong, based on the definitions of the 2013 paper and why?
>
*S. L. Tanimoto A perspective on the evolution of live programming Proceedings of the 1st International Workshop on Live Programming, LIVE 2013, 2013, 31-34*

### Steady Frame
>Which activities are designed as steady frames based on the formal definition and how?

*C. M. Hancock Real-Time Programming and the Big Ideas of Computational Literacy Massachusetts Institute of Technology, Massachusetts Institute of Technology, 2003*

### Impact on distances
>How do the activities affect the different distances: temporal, spatial, semantic?

*D. Ungar and H. Lieberman & C. Fry Debugging and the Experience of Immediacy Communications of the ACM, ACM, 1997, 40, 38-43*

---

## Implementing Liveness

### Extend of liveness in technical artifacts
>What parts of the system implements the liveness? (Execution environment, library, tool...)

### Implementations of single activities
>Description of the implementation of live activities. Each implementation pattern should be described through its concrete incarnation in the system (including detailed and specific code or code references) and as an abstract concept.

#### Example: Scrubbing
>The mouse event in the editor is captured and if the underlying AST element allows for scrubbing a slider is rendered. On changing the slider the value in the source code is adjusted, the method including the value is recompiled. After the method was compiled and installed in the class, the execution continues. When the method is executed during stepping the effects of the modified value become apparent.

>Abstract form: Scrubbing is enabled through incremental compilation which enables quick recompilation of parts of an application...

### Within or outside of the application
>For each activity: Does the activity happen from within the running application or is it made possible from something outside of the application? For example, a REPL works within a running process while the interactions with an auto test runner are based on re-running the application from the outside without any interactive access to process internal data.

---

## Benchmark
>1. **Unit of change:** Determine relevant units of change from the user perspective. Use the most common ones.
>2. **Relevant operations:** Determine relevant operations on these units of change (add, modify, delete, compound operations (for example refactorings)).
>3. **Example data:** Select, describe, and provide representative code samples which reflect the complexity or length of a common unit of change of the environment. The sample should also work in combination with any emergence mechanisms of the environment, for example a replay system works well for a system with user inputs and does not match a long-running computation.
>4. **Reproducible setup of system and benchmark**
  1. Description of installation on Ubuntu 16.04.1 LTS
  2. Description of instrumentation of system for measurements: The measurements should be taken as if a user was actually using a system. So the starting point of a measurement might be the keyboard event of the save keyboard shortcut or the event handler of a save button. At the same time the emergence phase ends when the rendering has finished and the result is perceivable. The run should include all activities which would be triggered when a developer saves a unit of change (for example regarding logging or persisting changes).
>5. **Results for adaptation and emergence phase**

*P. Rein and S. Lehmann and Toni & R. Hirschfeld How Live Are Live Programming Systems?: Benchmarking the Response Times of Live Programming Environments Proceedings of the Programming Experience Workshop (PX/16) 2016, ACM, 2016, 1-8*

---

## Personal observations
>Everything that is particular about the environment and does not fit into the pre-defined categories mentioned so far.

## Style Template
>- Denote headings with #
>- You can use any text highlighting, list types, and tables
>- Insert images in the following way:
>  `![This is the caption](/url/of/image.png)`
>- Insert videos or web resources as markdown links
>- Insert references as: `@RefKey` and supply a bib file
>- No HTML tags please
